#!/bin/zsh

# k8s-sync - Watch a folder and sync files to a target Kubernetes pod
# Author: Yuwei Liang

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Default values
SOURCE_DIR=""
POD_NAME=""
NAMESPACE="default"
CONTAINER=""
REMOTE_PATH="/tmp/sync"
WATCH_DELAY=1
EXCLUDE_PATTERNS=()
INCLUDE_PATTERNS=()
DRY_RUN=false
VERBOSE=false
GIT_MODE=true
ALL_FILES_MODE=false
MAX_FILE_SIZE=10485760  # 10MB default
DEBUG=false
NOTIFICATIONS=true
PER_FILE_NOTIFICATIONS=false

# Track synced files to avoid duplicates
declare -A SYNCED_FILES
declare -A LAST_SYNC_TIME

# Track sync statistics (using simple variables instead of associative array)
SYNC_SUCCESSFUL=0
SYNC_FAILED=0
SYNC_SKIPPED=0

# Send macOS notification
send_notification() {
    local title="$1"
    local message="$2"
    local subtitle="$3"
    
    if [[ "$NOTIFICATIONS" == true ]] && command -v osascript &> /dev/null; then
        osascript -e "display notification \"$message\" with title \"$title\" subtitle \"$subtitle\"" 2>/dev/null
    fi
}

# Test notification function
test_notification() {
    if [[ "$NOTIFICATIONS" == true ]]; then
        echo -e "${BLUE}Testing notification...${NC}"
        send_notification "Test Notification" "This is a test notification from k8s-sync" "Test"
        echo -e "${GREEN}Test notification sent!${NC}"
        echo "If you don't see it, check:"
        echo "  1. macOS notification permissions for Terminal/iTerm"
        echo "  2. Notification Center settings"
        echo "  3. Do Not Disturb mode"
    else
        echo -e "${YELLOW}Notifications are disabled${NC}"
    fi
}

# Send sync summary notification
send_sync_summary() {
    if [[ $SYNC_SUCCESSFUL -gt 0 ]] || [[ $SYNC_FAILED -gt 0 ]]; then
        local title="K8s Sync Complete"
        local message="Synced: $SYNC_SUCCESSFUL, Failed: $SYNC_FAILED, Skipped: $SYNC_SKIPPED"
        local subtitle="$POD_NAME ($NAMESPACE)"
        
        if [[ $SYNC_FAILED -eq 0 ]]; then
            send_notification "$title" "$message" "$subtitle"
        else
            send_notification "$title ‚ö†Ô∏è" "$message" "$subtitle"
        fi
    fi
}

# Reset sync statistics
reset_sync_stats() {
    SYNC_SUCCESSFUL=0
    SYNC_FAILED=0
    SYNC_SKIPPED=0
}

# Help function
show_help() {
    echo "Usage: k8s-sync [OPTIONS] <source_directory> <pod_name>"
    echo ""
    echo "Watch a folder and sync files to a target Kubernetes pod."
    echo ""
    echo "REQUIRED ARGUMENTS:"
    echo "  source_directory    Local directory to watch and sync"
    echo "  pod_name           Target Kubernetes pod name"
    echo ""
    echo "OPTIONS:"
    echo "  -h, --help              Show this help message"
    echo "  -n, --namespace NAME    Kubernetes namespace (default: default)"
    echo "  -c, --container NAME    Container name (if pod has multiple containers)"
    echo "  -r, --remote-path PATH  Remote path in pod (default: /tmp/sync)"
    echo "  -d, --delay SECONDS     Watch delay in seconds (default: 1)"
    echo "  -e, --exclude PATTERN   Exclude files matching pattern (can be used multiple times)"
    echo "  -i, --include PATTERN   Include only files matching pattern (can be used multiple times)"
    echo "  --all-files             Sync all files (not just Git-tracked files)"
    echo "  --max-size SIZE         Maximum file size in bytes (default: 10485760 = 10MB)"
    echo "  --no-notifications      Disable macOS notifications"
    echo "  --per-file-notifications Send notification for each file sync"
    echo "  --test-notifications    Test notification functionality"
    echo "  --dry-run               Show what would be synced without actually syncing"
    echo "  -v, --verbose           Verbose output"
    echo "  --debug                 Debug mode (shows all filtering decisions)"
    echo ""
    echo "EXAMPLES:"
    echo "  k8s-sync ./src my-app-pod                    # Sync Git-tracked files (default)"
    echo "  k8s-sync --all-files ./src my-app-pod        # Sync all files"
    echo "  k8s-sync -n prod ./config config-pod         # Sync to prod namespace"
    echo "  k8s-sync -e '*.log' -e '*.tmp' ./data pod    # Exclude log and temp files"
    echo "  k8s-sync -i '*.py' ./src python-pod          # Sync only Python files"
    echo "  k8s-sync --dry-run ./src test-pod            # Preview sync operations"
    echo "  k8s-sync --debug ./src test-pod              # Debug mode"
    echo "  k8s-sync --per-file-notifications ./src pod  # Notify for each file sync"
    echo "  k8s-sync --test-notifications                # Test notifications"
    echo ""
    echo "TROUBLESHOOTING:"
    echo "  If files aren't syncing, they might be:"
    echo "  - Not tracked by Git (use --all-files mode)"
    echo "  - Already committed with no changes (make a small change)"
    echo "  - Excluded by patterns (check -e options)"
    echo "  - Too large (check --max-size)"
    echo "  Use k8s-sync-debug <source_dir> <file_path> to debug specific files"
    echo "  If notifications aren't working:"
    echo "  - Check macOS notification permissions for Terminal/iTerm"
    echo "  - Use --per-file-notifications for individual file sync notifications"
    echo ""
    echo "DEPENDENCIES:"
    echo "  - kubectl (must be configured)"
    echo "  - fswatch (install with: brew install fswatch)"
    echo "  - git (for Git mode, which is default)"
    echo ""
    echo "Author: Yuwei Liang"
}

# Debug function
debug_log() {
    if [[ "$DEBUG" == true ]]; then
        echo -e "${PURPLE}[DEBUG] $1${NC}" >&2
    fi
}

# Check dependencies
check_dependencies() {
    local missing_deps=()
    
    if ! command -v kubectl &> /dev/null; then
        missing_deps+=("kubectl")
    fi
    
    if ! command -v fswatch &> /dev/null; then
        missing_deps+=("fswatch")
    fi
    
    if [[ "$GIT_MODE" == true ]] && ! command -v git &> /dev/null; then
        missing_deps+=("git")
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo -e "${RED}Error: Missing dependencies: ${missing_deps[*]}${NC}"
        echo ""
        echo "Install missing dependencies:"
        for dep in "${missing_deps[@]}"; do
            case $dep in
                kubectl)
                    echo "  kubectl: https://kubernetes.io/docs/tasks/tools/"
                    ;;
                fswatch)
                    echo "  fswatch: brew install fswatch"
                    ;;
                git)
                    echo "  git: brew install git"
                    ;;
            esac
        done
        exit 1
    fi
}

# Check if kubectl is configured
check_kubectl_config() {
    if ! kubectl cluster-info &> /dev/null; then
        echo -e "${RED}Error: kubectl is not configured or cannot connect to cluster${NC}"
        echo "Please configure kubectl with: kubectl config use-context <context>"
        exit 1
    fi
}

# Check if pod exists
check_pod_exists() {
    local pod=$1
    local namespace=$2
    
    if ! kubectl get pod "$pod" -n "$namespace" &> /dev/null; then
        echo -e "${RED}Error: Pod '$pod' not found in namespace '$namespace'${NC}"
        echo "Available pods in namespace '$namespace':"
        kubectl get pods -n "$namespace" --no-headers | awk '{print $1}'
        exit 1
    fi
    
    # Check if pod is running
    local pod_status=$(kubectl get pod "$pod" -n "$namespace" -o jsonpath='{.status.phase}')
    if [[ "$pod_status" != "Running" ]]; then
        echo -e "${YELLOW}Warning: Pod '$pod' is not running (status: $pod_status)${NC}"
        echo -n "Continue anyway? (y/N): "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
}

# Get file modification time
get_file_mtime() {
    local file=$1
    if [[ -f "$file" ]]; then
        stat -f %m "$file" 2>/dev/null || stat -c %Y "$file" 2>/dev/null
    else
        echo "0"
    fi
}

# Check if file has changed since last sync
has_file_changed() {
    local file=$1
    local current_mtime=$(get_file_mtime "$file")
    local last_mtime=${LAST_SYNC_TIME[$file]:-0}
    
    debug_log "File: $file, Current mtime: $current_mtime, Last mtime: $last_mtime"
    
    if [[ "$current_mtime" != "$last_mtime" ]]; then
        LAST_SYNC_TIME[$file_path]=$(($(date +%s) + 1))
        debug_log "File has changed: $file"
        return 0  # File has changed
    fi
    
    debug_log "File unchanged: $file"
    return 1  # File hasn't changed
}

# Get Git-tracked files
get_git_files() {
    local source_dir=$1
    local git_files=()
    
    # Change to source directory to run git commands
    cd "$source_dir" || return 1
    
    # Get modified, staged, and untracked files
    # Redirect debug output to stderr to avoid capturing it in command substitution
    local modified_files=($(git status --porcelain | grep '^ M\|^M ' | awk '{print $2}' 2>/dev/null))
    local staged_files=($(git status --porcelain | grep '^M ' | awk '{print $2}' 2>/dev/null))
    local untracked_files=($(git status --porcelain | grep '^??' | awk '{print $2}' 2>/dev/null))
    
    debug_log "Git modified files: ${modified_files[*]}" >&2
    debug_log "Git staged files: ${staged_files[*]}" >&2
    debug_log "Git untracked files: ${untracked_files[*]}" >&2
    
    # Combine all files
    git_files=("${modified_files[@]}" "${staged_files[@]}" "${untracked_files[@]}")
    
    # Convert to absolute paths
    local absolute_files=()
    for file in "${git_files[@]}"; do
        if [[ -f "$file" ]]; then
            absolute_files+=("$(realpath "$file")")
        fi
    done
    
    debug_log "Git absolute files: ${absolute_files[*]}" >&2
    echo "${absolute_files[@]}"
}

# Check if file is Git-tracked and modified
is_git_tracked_and_modified() {
    local file_path=$1
    local relative_path=${file_path#$SOURCE_DIR/}
    
    # Change to source directory to run git commands
    cd "$SOURCE_DIR" || return 1
    
    # Check if file is in git status (modified, staged, or untracked)
    local git_status=$(git status --porcelain "$relative_path" 2>/dev/null)
    debug_log "Git status for $relative_path: '$git_status'"
    
    if echo "$git_status" | grep -q .; then
        debug_log "File is Git-tracked and modified: $file_path"
        return 0  # File is tracked and modified
    fi
    
    debug_log "File is not Git-tracked or not modified: $file_path"
    return 1  # File is not tracked or not modified
}

# Check if file should be ignored (temporary files, etc.)
should_ignore_file() {
    local file_path=$1
    local filename=$(basename "$file_path")
    
    # Ignore common temporary and system files
    local ignore_patterns=(
        "*.lock"
        "*.tmp"
        "*.temp"
        "*.swp"
        "*.swo"
        "*~"
        ".DS_Store"
        "Thumbs.db"
        ".git/index.lock"
        ".git/refs/heads/*.lock"
        ".git/refs/tags/*.lock"
        "*.pyc"
        "__pycache__"
        "node_modules"
        ".pytest_cache"
        ".coverage"
        "*.log"
    )
    
    for pattern in "${ignore_patterns[@]}"; do
        if [[ "$filename" == $pattern ]] || [[ "$file_path" == *"$pattern"* ]]; then
            debug_log "File ignored by pattern '$pattern': $file_path"
            return 0  # Should ignore
        fi
    done
    
    debug_log "File not ignored: $file_path"
    return 1  # Should not ignore
}

# Sync file to pod
sync_file() {
    local file_path=$1
    local relative_path=$2
    
    debug_log "Attempting to sync: $file_path"
    
    # Check if file has actually changed
    if ! has_file_changed "$file_path"; then
        [[ "$VERBOSE" == true ]] && echo -e "${PURPLE}Skipping unchanged file: $relative_path${NC}"
        ((SYNC_SKIPPED++))
        return
    fi
    
    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${CYAN}[DRY RUN] Would sync: $file_path -> $POD_NAME:$REMOTE_PATH/$relative_path${NC}"
        SYNCED_FILES[$file_path]=1
        return
    fi

    # Print pre-sync message
    echo -e "${BLUE}‚ü≥ Syncing: $relative_path${NC}"
    
    # Create remote directory structure
    local remote_dir=$(dirname "$REMOTE_PATH/$relative_path")
    debug_log "Creating remote directory: $remote_dir"
    
    local mkdir_output=$(kubectl exec "$POD_NAME" -n "$NAMESPACE" ${CONTAINER:+ -c "$CONTAINER"} -- mkdir -p "$remote_dir" 2>&1)
    if [[ $? -ne 0 ]]; then
        debug_log "Failed to create remote directory: $mkdir_output"
        echo -e "${RED}‚úó Failed to create remote directory: $remote_dir${NC}"
        ((SYNC_FAILED++))
        return
    fi
    
    # Get current time before sync (add 1 second to ensure it's ahead)
    LAST_SYNC_TIME[$file_path]=$(($(date +%s) + 1))
    
    # Copy file to pod - using the exact format that worked manually
    local kubectl_cmd="kubectl cp \"$file_path\" \"$NAMESPACE/$POD_NAME:$REMOTE_PATH/$relative_path\""
    if [[ -n "$CONTAINER" ]]; then
        kubectl_cmd="$kubectl_cmd -c \"$CONTAINER\""
    fi
    
    debug_log "Running: $kubectl_cmd"
    
    # Execute the command exactly as it would be run manually
    local cp_output
    if [[ -n "$CONTAINER" ]]; then
        cp_output=$(kubectl cp "$file_path" "$NAMESPACE/$POD_NAME:$REMOTE_PATH/$relative_path" -c "$CONTAINER" 2>&1)
    else
        cp_output=$(kubectl cp "$file_path" "$NAMESPACE/$POD_NAME:$REMOTE_PATH/$relative_path" 2>&1)
    fi
    local cp_exit_code=$?
    
    debug_log "kubectl cp exit code: $cp_exit_code"
    debug_log "kubectl cp output: '$cp_output'"
    
    if [[ $cp_exit_code -eq 0 ]]; then
        # Verify the file was actually copied
        debug_log "Verifying file was copied..."
        local verify_cmd="kubectl exec \"$POD_NAME\" -n \"$NAMESPACE\""
        if [[ -n "$CONTAINER" ]]; then
            verify_cmd="$verify_cmd -c \"$CONTAINER\""
        fi
        verify_cmd="$verify_cmd -- ls -la \"$REMOTE_PATH/$relative_path\""
        
        debug_log "Running verification: $verify_cmd"
        
        local verify_output
        if [[ -n "$CONTAINER" ]]; then
            verify_output=$(kubectl exec "$POD_NAME" -n "$NAMESPACE" -c "$CONTAINER" -- ls -la "$REMOTE_PATH/$relative_path" 2>&1)
        else
            verify_output=$(kubectl exec "$POD_NAME" -n "$NAMESPACE" -- ls -la "$REMOTE_PATH/$relative_path" 2>&1)
        fi
        local verify_exit_code=$?
        
        debug_log "File verification exit code: $verify_exit_code"
        debug_log "File verification output: '$verify_output'"
        
        if [[ $verify_exit_code -eq 0 ]]; then
            echo -e "${GREEN}‚úì Synced: $relative_path${NC}"
            SYNCED_FILES[$file_path]=1
            ((SYNC_SUCCESSFUL++))
        else
            echo -e "${RED}‚úó File sync appeared successful but file not found: $relative_path${NC}"
            echo -e "${RED}Verification error: $verify_output${NC}"
            ((SYNC_FAILED++))
        fi
    else
        echo -e "${RED}‚úó Failed to sync: $relative_path${NC}"
        echo -e "${RED}Error: $cp_output${NC}"
        ((SYNC_FAILED++))
    fi
}

# Remove file from pod
remove_file() {
    local relative_path=$1
    
    # Don't remove files that we should ignore
    if should_ignore_file "$SOURCE_DIR/$relative_path"; then
        [[ "$VERBOSE" == true ]] && echo -e "${PURPLE}Skipping removal of ignored file: $relative_path${NC}"
        return
    fi
    
    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${CYAN}[DRY RUN] Would remove: $POD_NAME:$REMOTE_PATH/$relative_path${NC}"
        return
    fi
    
    if kubectl exec "$POD_NAME" -n "$NAMESPACE" ${CONTAINER:+ -c "$CONTAINER"} -- rm -f "$REMOTE_PATH/$relative_path" &>/dev/null; then
        echo -e "${YELLOW}üóëÔ∏è  Removed: $relative_path${NC}"
    else
        echo -e "${RED}‚úó Failed to remove: $relative_path${NC}"
    fi
}

# Check if file should be synced
should_sync_file() {
    local file_path=$1
    local filename=$(basename "$file_path")
    
    debug_log "Checking if should sync: $file_path"
    
    # Skip ignored files
    if should_ignore_file "$file_path"; then
        debug_log "File should not be synced (ignored): $file_path"
        return 1
    fi
    
    # Check file size
    local file_size=$(stat -f %z "$file_path" 2>/dev/null || stat -c %s "$file_path" 2>/dev/null)
    debug_log "File size: $file_size bytes (max: $MAX_FILE_SIZE)"
    
    if [[ "$file_size" -gt "$MAX_FILE_SIZE" ]]; then
        debug_log "File too large (>${MAX_FILE_SIZE} bytes): $file_path"
        [[ "$VERBOSE" == true ]] && echo -e "${PURPLE}Skipping large file (>${MAX_FILE_SIZE} bytes): $file_path${NC}"
        return 1
    fi
    
    # Check exclude patterns
    for pattern in "${EXCLUDE_PATTERNS[@]}"; do
        if [[ "$filename" == $pattern ]] || [[ "$file_path" == *"$pattern"* ]]; then
            debug_log "File excluded by pattern '$pattern': $file_path"
            [[ "$VERBOSE" == true ]] && echo -e "${PURPLE}Skipping (excluded): $file_path${NC}"
            return 1
        fi
    done
    
    # Check include patterns (if any specified)
    if [[ ${#INCLUDE_PATTERNS[@]} -gt 0 ]]; then
        local should_include=false
        for pattern in "${INCLUDE_PATTERNS[@]}"; do
            if [[ "$filename" == $pattern ]] || [[ "$file_path" == *"$pattern"* ]]; then
                should_include=true
                break
            fi
        done
        if [[ "$should_include" == false ]]; then
            debug_log "File not included by any pattern: $file_path"
            [[ "$VERBOSE" == true ]] && echo -e "${PURPLE}Skipping (not included): $file_path${NC}"
            return 1
        fi
    fi
    
    debug_log "File should be synced: $file_path"
    return 0
}

# Test kubectl connection and pod access
test_pod_access() {
    local pod=$1
    local namespace=$2
    local container=$3
    
    debug_log "Testing pod access: $pod in namespace $namespace"
    
    # Test basic pod access
    local pod_test=$(kubectl get pod "$pod" -n "$namespace" -o jsonpath='{.status.phase}' 2>&1)
    if [[ $? -ne 0 ]]; then
        echo -e "${RED}‚úó Cannot access pod: $pod_test${NC}"
        return 1
    fi
    
    debug_log "Pod status: $pod_test"
    
    # Test exec access
    local exec_test=$(kubectl exec "$pod" -n "$namespace" ${container:+ -c "$container"} -- echo "test" 2>&1)
    if [[ $? -ne 0 ]]; then
        echo -e "${RED}‚úó Cannot exec into pod: $exec_test${NC}"
        return 1
    fi
    
    debug_log "Exec test successful: $exec_test"
    
    # Test directory creation
    local mkdir_test=$(kubectl exec "$pod" -n "$namespace" ${container:+ -c "$container"} -- mkdir -p /tmp/k8s-sync-test 2>&1)
    if [[ $? -ne 0 ]]; then
        echo -e "${RED}‚úó Cannot create directories in pod: $mkdir_test${NC}"
        return 1
    fi
    
    debug_log "Directory creation test successful"
    
    # Clean up test directory
    kubectl exec "$pod" -n "$namespace" ${container:+ -c "$container"} -- rm -rf /tmp/k8s-sync-test 2>/dev/null
    
    echo -e "${GREEN}‚úì Pod access test successful${NC}"
    return 0
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -n|--namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        -c|--container)
            CONTAINER="$2"
            shift 2
            ;;
        -r|--remote-path)
            REMOTE_PATH="$2"
            shift 2
            ;;
        -d|--delay)
            WATCH_DELAY="$2"
            shift 2
            ;;
        -e|--exclude)
            EXCLUDE_PATTERNS+=("$2")
            shift 2
            ;;
        -i|--include)
            INCLUDE_PATTERNS+=("$2")
            shift 2
            ;;
        --all-files)
            GIT_MODE=false
            ALL_FILES_MODE=true
            shift
            ;;
        --max-size)
            MAX_FILE_SIZE="$2"
            shift 2
            ;;
        --no-notifications)
            NOTIFICATIONS=false
            shift
            ;;
        --per-file-notifications)
            PER_FILE_NOTIFICATIONS=true
            shift
            ;;
        --test-notifications)
            test_notification
            exit 0
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        --debug)
            DEBUG=true
            VERBOSE=true
            shift
            ;;
        -*)
            echo -e "${RED}Error: Unknown option $1${NC}"
            echo "Use -h or --help for usage information."
            exit 1
            ;;
        *)
            if [[ -z "$SOURCE_DIR" ]]; then
                SOURCE_DIR="$1"
            elif [[ -z "$POD_NAME" ]]; then
                POD_NAME="$1"
            else
                echo -e "${RED}Error: Too many arguments${NC}"
                echo "Use -h or --help for usage information."
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate required arguments
if [[ -z "$SOURCE_DIR" ]] || [[ -z "$POD_NAME" ]]; then
    echo -e "${RED}Error: Missing required arguments${NC}"
    echo "Usage: k8s-sync [OPTIONS] <source_directory> <pod_name>"
    echo "Use -h or --help for usage information."
    exit 1
fi

# Check if source directory exists
if [[ ! -d "$SOURCE_DIR" ]]; then
    echo -e "${RED}Error: Source directory '$SOURCE_DIR' does not exist${NC}"
    exit 1
fi

# Get absolute path of source directory
SOURCE_DIR=$(cd "$SOURCE_DIR" && pwd)

# Check if it's a git repository (for git mode)
if [[ "$GIT_MODE" == true ]]; then
    if [[ ! -d "$SOURCE_DIR/.git" ]]; then
        echo -e "${RED}Error: Source directory '$SOURCE_DIR' is not a Git repository${NC}"
        echo "Use --all-files to sync all files instead of Git-tracked files only."
        exit 1
    fi
fi

# Check dependencies
check_dependencies

# Check kubectl configuration
check_kubectl_config

# Check if pod exists
check_pod_exists "$POD_NAME" "$NAMESPACE"

# After checking if pod exists, add this:
if [[ "$DEBUG" == true ]]; then
    echo -e "${BLUE}Testing pod access...${NC}"
    test_pod_access "$POD_NAME" "$NAMESPACE" "$CONTAINER"
    echo ""
fi

# Display configuration
echo -e "${BLUE}K8s Sync Configuration:${NC}"
echo "  Source Directory: $SOURCE_DIR"
echo "  Target Pod: $POD_NAME"
echo "  Namespace: $NAMESPACE"
[[ -n "$CONTAINER" ]] && echo "  Container: $CONTAINER"
echo "  Remote Path: $REMOTE_PATH"
echo "  Watch Delay: ${WATCH_DELAY}s"
echo "  Max File Size: ${MAX_FILE_SIZE} bytes ($(($MAX_FILE_SIZE / 1024 / 1024))MB)"
if [[ "$GIT_MODE" == true ]]; then
    echo -e "  ${GREEN}Mode: Git-tracked files only (default)${NC}"
else
    echo -e "  ${YELLOW}Mode: All files${NC}"
fi
[[ ${#EXCLUDE_PATTERNS[@]} -gt 0 ]] && echo "  Exclude Patterns: ${EXCLUDE_PATTERNS[*]}"
[[ ${#INCLUDE_PATTERNS[@]} -gt 0 ]] && echo "  Include Patterns: ${INCLUDE_PATTERNS[*]}"
[[ "$DRY_RUN" == true ]] && echo -e "  ${CYAN}DRY RUN MODE${NC}"
[[ "$DEBUG" == true ]] && echo -e "  ${PURPLE}DEBUG MODE${NC}"
[[ "$NOTIFICATIONS" == true ]] && echo -e "  ${GREEN}Notifications: Enabled${NC}"
[[ "$NOTIFICATIONS" == false ]] && echo -e "  ${YELLOW}Notifications: Disabled${NC}"
[[ "$PER_FILE_NOTIFICATIONS" == true ]] && echo -e "  ${CYAN}Per-file notifications: Enabled${NC}"
echo ""

# Reset sync statistics
reset_sync_stats

# Initial sync
echo -e "${BLUE}Performing initial sync...${NC}"

if [[ "$GIT_MODE" == true ]]; then
    # Sync only Git-tracked files
    local git_files=($(get_git_files "$SOURCE_DIR"))
    if [[ ${#git_files[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No Git-tracked files to sync${NC}"
    else
        for file in "${git_files[@]}"; do
            if should_sync_file "$file"; then
                relative_path=${file#$SOURCE_DIR/}
                sync_file "$file" "$relative_path"
            fi
        done
    fi
else
    # Sync all files
    find "$SOURCE_DIR" -type f | while read -r file; do
        if should_sync_file "$file"; then
            relative_path=${file#$SOURCE_DIR/}
            sync_file "$file" "$relative_path"
        fi
    done
fi

echo -e "${GREEN}Initial sync complete!${NC}"

# Send initial sync notification
if [[ "$DRY_RUN" != true ]]; then
    send_sync_summary
fi

echo -e "${BLUE}Watching for changes... (Press Ctrl+C to stop)${NC}"
echo ""

# Set up signal handler for graceful shutdown
cleanup() {
    echo ""
    echo -e "${BLUE}Shutting down k8s-sync...${NC}"
    
    # Send final sync summary
    if [[ "$DRY_RUN" != true ]]; then
        send_sync_summary
    fi
    
    exit 0
}

trap cleanup SIGINT SIGTERM

# Watch for changes using fswatch for both modes
fswatch -r -l "$WATCH_DELAY" "$SOURCE_DIR" | while read -r file; do
    debug_log "fswatch detected change: $file"
    
    # Skip if file doesn't exist (was deleted)
    if [[ ! -e "$file" ]]; then
        debug_log "File doesn't exist (deleted): $file"
        relative_path=${file#$SOURCE_DIR/}
        remove_file "$relative_path"
        
        # Send notification for file removal if per-file notifications are enabled
        if [[ "$PER_FILE_NOTIFICATIONS" == true ]] && [[ "$NOTIFICATIONS" == true ]]; then
            send_notification "File Removed" "$relative_path" "$POD_NAME ($NAMESPACE)"
        fi
        continue
    fi
    
    # Skip directories
    if [[ -d "$file" ]]; then
        debug_log "Directory change detected: $file"
        [[ "$VERBOSE" == true ]] && echo -e "${PURPLE}Directory change detected: $file${NC}"
        continue
    fi
    
    # For Git mode, check if file is Git-tracked and modified
    if [[ "$GIT_MODE" == true ]]; then
        if ! is_git_tracked_and_modified "$file"; then
            debug_log "Skipping non-Git-tracked file: $file"
            [[ "$VERBOSE" == true ]] && echo -e "${PURPLE}Skipping non-Git-tracked file: $file${NC}"
            continue
        fi
    fi
    
    # Check if file should be synced
    if should_sync_file "$file"; then
        relative_path=${file#$SOURCE_DIR/}
        sync_file "$file" "$relative_path"
        
        # Send notification after each sync if per-file notifications are enabled
        if [[ "$PER_FILE_NOTIFICATIONS" == true ]] && [[ "$NOTIFICATIONS" == true ]]; then
            send_notification "File Synced" "$relative_path" "$POD_NAME ($NAMESPACE)"
        fi
    else
        # Notify about skipped files if verbose and notifications enabled
        if [[ "$VERBOSE" == true ]] && [[ "$NOTIFICATIONS" == true ]]; then
            relative_path=${file#$SOURCE_DIR/}
            send_notification "File Skipped" "$relative_path" "$POD_NAME ($NAMESPACE)"
        fi
    fi
done 